import {
    ensureError,
    extractErrorMessage,
    getEnumValues,
    getObjectTypedKeys,
    HttpMethod,
    HttpStatus,
    randomString,
    SelectFrom,
} from '@augment-vir/common';
import fastifyWs from '@fastify/websocket';
import type {BaseSearchParams} from '@rest-vir/define-service';
import {
    GenericServiceImplementation,
    RestVirHandlerError,
    ServiceImplementation,
} from '@rest-vir/implement-service';
import {type FastifyInstance} from 'fastify';
import {HandleRouteOptions} from '../handle-request/endpoint-handler.js';
import {handleRoute} from '../handle-request/handle-route.js';
import {preHandler} from '../handle-request/pre-handler.js';

declare module 'fastify' {
    interface FastifyRequest {
        restVirContext:
            | {
                  /**
                   * {@link attachService} can be called multiple times. Each time it is called, a
                   * new `AttachId` is generated and contexts generated by that attachment are
                   * stored in the request under that id.
                   */
                  [AttachId in string]: {
                      context: unknown;
                      requestData: unknown;
                      protocols: string[];
                      searchParams: BaseSearchParams;
                  };
              }
            | undefined;
    }
}

const endpointFastifyMethods = getEnumValues(HttpMethod).filter((value) => {
    return (
        /** Fastify doesn't support the CONNECT method. */
        value !== HttpMethod.Connect &&
        /** We use the GET method in a separate handler so it can handle WebSocket requests as well. */
        value !== HttpMethod.Get
    );
});

/**
 * Attach all handlers for a {@link ServiceImplementation} to any existing Fastify server.
 *
 * @category Run Service
 * @category Package : @rest-vir/run-service
 * @example
 *
 * ```ts
 * import fastify from 'fastify';
 *
 * const server = fastify();
 *
 * attachService(service, myServiceImplementation);
 *
 * await server.listen({port: 3000});
 * ```
 *
 * @package [`@rest-vir/run-service`](https://www.npmjs.com/package/@rest-vir/run-service)
 */
export async function attachService(
    server: Readonly<FastifyInstance>,
    service: Readonly<
        SelectFrom<
            GenericServiceImplementation,
            {
                webSockets: true;
                endpoints: true;
                serviceName: true;
                createContext: true;
                serviceOrigin: true;
                requiredClientOrigin: true;
                logger: true;
            }
        >
    >,
    options: Readonly<HandleRouteOptions> = {},
): Promise<void> {
    try {
        const attachId = randomString(32);

        if (!server.hasRequestDecorator('restVirContext')) {
            server.decorateRequest('restVirContext');
        }
        if (!server.hasRequestDecorator('ws')) {
            await server.register(fastifyWs, {
                /* node:coverage ignore next 14: edge case handling */
                errorHandler(error, webSocket, request) {
                    service.logger.error(
                        new RestVirHandlerError(
                            {
                                isEndpoint: false,
                                isWebSocket: true,
                                path: request.originalUrl,
                                service,
                            },
                            extractErrorMessage(error),
                        ),
                    );
                    webSocket.terminate();
                },
            });
        }

        server.addHook('preValidation', async (request, response) => {
            try {
                await preHandler(request, response, service, attachId);
            } catch (error) {
                service.logger.error(ensureError(error));
                if (options.throwErrorsForExternalHandling) {
                    throw error;
                } else if (!response.sent) {
                    response.statusCode = HttpStatus.InternalServerError;
                    response.send();
                }
            }
        });

        const allPaths = new Set([
            ...getObjectTypedKeys(service.webSockets),
            ...getObjectTypedKeys(service.endpoints),
        ]);

        allPaths.forEach((path) => {
            const webSocketDefinition = service.webSockets[path];
            const endpoint = service.endpoints[path];

            if (endpoint && webSocketDefinition) {
                server.route({
                    method: endpointFastifyMethods,
                    url: path,
                    async handler(request, response) {
                        await handleRoute(
                            undefined,
                            request,
                            response,
                            endpoint,
                            attachId,
                            options,
                        );
                    },
                });
                server.route({
                    method: HttpMethod.Get,
                    url: path,
                    async handler(request, response) {
                        await handleRoute(
                            undefined,
                            request,
                            response,
                            endpoint,
                            attachId,
                            options,
                        );
                    },
                    async wsHandler(webSocket, request) {
                        await handleRoute(
                            webSocket,
                            request,
                            undefined,
                            webSocketDefinition,
                            attachId,
                            options,
                        );
                    },
                });
            } else if (endpoint) {
                server.route({
                    method: [
                        ...endpointFastifyMethods,
                        HttpMethod.Get,
                    ],
                    url: path,
                    async handler(request, response) {
                        await handleRoute(
                            undefined,
                            request,
                            response,
                            endpoint,
                            attachId,
                            options,
                        );
                    },
                });
            } else if (webSocketDefinition) {
                server.route({
                    method: HttpMethod.Get,
                    url: path,
                    handler(request, response) {
                        response.status(HttpStatus.NotFound).send();
                    },
                    async wsHandler(webSocket, request) {
                        await handleRoute(
                            webSocket,
                            request,
                            undefined,
                            webSocketDefinition,
                            attachId,
                            options,
                        );
                    },
                });
            }
        });

        /* node:coverage ignore next 4: this is just here to cover edge cases. */
    } catch (error) {
        service.logger.error(ensureError(error));
        throw error;
    }
}
